import * as fs from 'fs'
import * as path from 'path'
import * as dotenv from 'dotenv'
import { 
  ContractName, 
  CONTRACT_ENV_MAPPING, 
  SCHEMA_ENV_MAPPING,
  ALL_CHAIN_NAMES,
  CHAIN_NAME_TO_ID 
} from '../app/contracts/config/types'

// Generate contract configuration directly from ContractName enum - no conversion needed!
const CONTRACT_CONFIG = Object.values(ContractName).reduce((acc, contractName) => {
  acc[contractName] = contractName // Direct mapping - enum value is already PascalCase
  return acc
}, {} as Record<string, string>)

// Helper function to get first non-empty env var value
function getEnvValue(vars: Record<string, string>, envVarNames: readonly string[]): string {
  for (const envVarName of envVarNames) {
    if (vars[envVarName]) {
      return vars[envVarName]
    }
  }
  return ''
}

// Parse each chain's env file
const envConfigs: Record<string, Record<string, string>> = {}
for (const chain of ALL_CHAIN_NAMES) {
  const envFile = path.resolve(process.cwd(), `.env.${chain}.local`)
  if (fs.existsSync(envFile)) {
    console.log(`Loading ${chain} config from ${envFile}`)
    envConfigs[chain] = dotenv.parse(fs.readFileSync(envFile))
  } else {
    console.log(`No env file found for ${chain} at ${envFile}`)
    envConfigs[chain] = {}
  }
}

// Build the configuration object
const configByChain: Record<number, {
  contracts: Record<string, string>
  schemas: Record<string, string>
}> = {}

for (const [chain, vars] of Object.entries(envConfigs)) {
  const chainId = CHAIN_NAME_TO_ID[chain as keyof typeof CHAIN_NAME_TO_ID]
  if (chainId && vars) {
    // Build contracts config using the mapping
    const contracts: Record<string, string> = {}
    Object.entries(CONTRACT_ENV_MAPPING).forEach(([contractName, envVarNames]) => {
      const configKey = CONTRACT_CONFIG[contractName]
      contracts[configKey] = getEnvValue(vars, envVarNames)
    })

    // Build schemas config using the mapping - no conversion needed!
    const schemas: Record<string, string> = {}
    Object.entries(SCHEMA_ENV_MAPPING).forEach(([schemaName, envVarName]) => {
      schemas[schemaName] = vars[envVarName] || '' // Direct mapping - enum value is already PascalCase
    })

    configByChain[chainId] = {
      contracts,
      schemas
    }
  }
}

console.log('Generated CONTRACT_CONFIG:', CONTRACT_CONFIG)

// Generate TypeScript file
const tsContent = `// Auto-generated file - do not edit manually
// Generated by scripts/generate-chain-config.ts

export const CHAIN_CONFIG = ${JSON.stringify(configByChain, null, 2)} as const

export const CONTRACT_NAME_MAPPING = ${JSON.stringify(CONTRACT_CONFIG, null, 2)} as const

export type ChainConfig = typeof CHAIN_CONFIG
export type SupportedChainId = keyof ChainConfig
export type ContractNameMapping = typeof CONTRACT_NAME_MAPPING
`

// Write the TypeScript file
const outputPath = path.resolve(process.cwd(), 'app/contracts/config/generated-chain-config.ts')
fs.writeFileSync(outputPath, tsContent)

console.log(`Chain configuration written to ${outputPath}`)
console.log('Supported chains:', Object.keys(configByChain).join(', ')) 